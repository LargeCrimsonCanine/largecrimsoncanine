"""
Python code generator for geometric algebra.

Generates standalone Python modules with optimized, unrolled operations
for specific algebras.
"""

from typing import List, Dict, Tuple, Optional
from . import Algebra, blade_grade


class PythonGenerator:
    """
    Generator for optimized Python code.

    Produces standalone .py files with unrolled product functions,
    specialized constructors, and grade projections.
    """

    def __init__(self, use_numpy: bool = False):
        """
        Initialize the Python generator.

        Args:
            use_numpy: If True, generate NumPy-based code for arrays.
                       If False, generate pure Python with lists.
        """
        self.use_numpy = use_numpy

    def generate_header(self, algebra: Algebra, module_name: str) -> str:
        """Generate module docstring and imports."""
        lines = [
            f'"""',
            f'Optimized geometric algebra operations for {algebra.signature}.',
            f'',
            f'Auto-generated by LargeCrimsonCanine codegen.',
            f'',
            f'Algebra: {algebra.signature}',
            f'Dimension: {algebra.dimension}',
            f'Blades: {algebra.num_blades}',
            f'"""',
            f'',
            f'from typing import List, Tuple',
        ]

        if self.use_numpy:
            lines.append('import numpy as np')

        lines.extend([
            '',
            f'# Algebra constants',
            f'DIMENSION = {algebra.dimension}',
            f'NUM_BLADES = {algebra.num_blades}',
            f'SIGNATURE = ({algebra.p}, {algebra.q}, {algebra.r})',
            '',
        ])

        return '\n'.join(lines)

    def generate_blade_names(self, algebra: Algebra) -> str:
        """Generate blade name constants."""
        lines = ['# Blade names and indices']
        for i in range(algebra.num_blades):
            name = algebra.blade_name(i).upper()
            if name == '1':
                name = 'SCALAR'
            lines.append(f'{name} = {i}')
        lines.append('')
        return '\n'.join(lines)

    def generate_grade_masks(self, algebra: Algebra) -> str:
        """Generate grade mask constants."""
        lines = ['# Grade masks (bit i set if blade i has that grade)']
        for grade in range(algebra.dimension + 1):
            mask = algebra.grade_masks[grade]
            lines.append(f'GRADE_{grade}_MASK = 0x{mask:x}')
        lines.append('')
        return '\n'.join(lines)

    def generate_constructor(self, algebra: Algebra) -> str:
        """Generate constructor functions."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def zero() -> {array_type}:',
            f'    """Create a zero multivector."""',
            f'    return {zeros}',
            f'',
            f'',
            f'def scalar(value: float) -> {array_type}:',
            f'    """Create a scalar multivector."""',
            f'    result = {zeros}',
            f'    result[0] = value',
            f'    return result',
            f'',
            f'',
            f'def vector(coords: List[float]) -> {array_type}:',
            f'    """Create a vector from coordinates."""',
            f'    assert len(coords) == DIMENSION',
            f'    result = {zeros}',
        ]

        # Vector blades (grade 1)
        vec_blades = algebra.blades_of_grade(1)
        for idx, blade_idx in enumerate(vec_blades):
            lines.append(f'    result[{blade_idx}] = coords[{idx}]')

        lines.extend([
            f'    return result',
            f'',
            f'',
            f'def basis(i: int) -> {array_type}:',
            f'    """Create the i-th basis vector (1-indexed)."""',
            f'    assert 1 <= i <= DIMENSION',
            f'    result = {zeros}',
            f'    result[1 << (i - 1)] = 1.0',
            f'    return result',
            f'',
        ])

        return '\n'.join(lines)

    def generate_geometric_product(self, algebra: Algebra) -> str:
        """Generate unrolled geometric product function."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def geometric_product(a: {array_type}, b: {array_type}) -> {array_type}:',
            f'    """',
            f'    Compute the geometric product a * b.',
            f'    ',
            f'    Fully unrolled for {algebra.signature}.',
            f'    """',
            f'    result = {zeros}',
            f'',
        ]

        # Group terms by result blade
        terms_by_blade: Dict[int, List[Tuple[int, int, float]]] = {i: [] for i in range(n)}

        for i in range(n):
            for j in range(n):
                result_blade, sign = algebra.product(i, j)
                if sign != 0.0:
                    terms_by_blade[result_blade].append((i, j, sign))

        # Generate code for each result blade
        for blade_idx in range(n):
            terms = terms_by_blade[blade_idx]
            if not terms:
                continue

            blade_name = algebra.blade_name(blade_idx)

            # Build expression
            expr_parts = []
            for i, j, sign in terms:
                if sign == 1.0:
                    expr_parts.append(f'a[{i}] * b[{j}]')
                elif sign == -1.0:
                    expr_parts.append(f'-a[{i}] * b[{j}]')
                else:
                    # Shouldn't happen for non-degenerate terms
                    expr_parts.append(f'{sign} * a[{i}] * b[{j}]')

            # Split into multiple lines if too long
            if len(expr_parts) <= 4:
                expr = ' + '.join(expr_parts).replace('+ -', '- ')
                lines.append(f'    result[{blade_idx}] = {expr}  # {blade_name}')
            else:
                lines.append(f'    # {blade_name}')
                lines.append(f'    result[{blade_idx}] = (')
                for k, part in enumerate(expr_parts):
                    sep = '' if k == 0 else '+ '
                    if part.startswith('-'):
                        sep = '- ' if k > 0 else ''
                        part = part[1:]
                    lines.append(f'        {sep}{part}' + (',' if k < len(expr_parts) - 1 else ''))
                lines.append(f'    )')

        lines.extend([
            f'',
            f'    return result',
            f'',
        ])

        return '\n'.join(lines)

    def generate_outer_product(self, algebra: Algebra) -> str:
        """Generate unrolled outer (wedge) product function."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def outer_product(a: {array_type}, b: {array_type}) -> {array_type}:',
            f'    """',
            f'    Compute the outer (wedge) product a ^ b.',
            f'    ',
            f'    Keeps only terms where grade(result) = grade(a) + grade(b).',
            f'    """',
            f'    result = {zeros}',
            f'',
        ]

        # Group terms by result blade (outer product only)
        terms_by_blade: Dict[int, List[Tuple[int, int, float]]] = {i: [] for i in range(n)}

        for i in range(n):
            grade_i = blade_grade(i)
            for j in range(n):
                grade_j = blade_grade(j)
                result_blade, sign = algebra.product(i, j)
                grade_result = blade_grade(result_blade)

                # Outer product: only keep if grade increases additively
                if sign != 0.0 and grade_result == grade_i + grade_j:
                    terms_by_blade[result_blade].append((i, j, sign))

        # Generate code for each result blade
        for blade_idx in range(n):
            terms = terms_by_blade[blade_idx]
            if not terms:
                continue

            blade_name = algebra.blade_name(blade_idx)
            expr_parts = []
            for i, j, sign in terms:
                if sign == 1.0:
                    expr_parts.append(f'a[{i}] * b[{j}]')
                elif sign == -1.0:
                    expr_parts.append(f'-a[{i}] * b[{j}]')

            if len(expr_parts) <= 4:
                expr = ' + '.join(expr_parts).replace('+ -', '- ')
                lines.append(f'    result[{blade_idx}] = {expr}  # {blade_name}')
            else:
                lines.append(f'    # {blade_name}')
                lines.append(f'    result[{blade_idx}] = (')
                for k, part in enumerate(expr_parts):
                    sep = '' if k == 0 else '+ '
                    if part.startswith('-'):
                        sep = '- ' if k > 0 else ''
                        part = part[1:]
                    lines.append(f'        {sep}{part}' + (',' if k < len(expr_parts) - 1 else ''))
                lines.append(f'    )')

        lines.extend([
            f'',
            f'    return result',
            f'',
        ])

        return '\n'.join(lines)

    def generate_inner_product(self, algebra: Algebra) -> str:
        """Generate unrolled inner (dot) product function."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def inner_product(a: {array_type}, b: {array_type}) -> {array_type}:',
            f'    """',
            f'    Compute the left contraction a . b.',
            f'    ',
            f'    Keeps only terms where grade(result) = |grade(b) - grade(a)|.',
            f'    """',
            f'    result = {zeros}',
            f'',
        ]

        # Group terms by result blade (inner product only)
        terms_by_blade: Dict[int, List[Tuple[int, int, float]]] = {i: [] for i in range(n)}

        for i in range(n):
            grade_i = blade_grade(i)
            for j in range(n):
                grade_j = blade_grade(j)
                result_blade, sign = algebra.product(i, j)
                grade_result = blade_grade(result_blade)

                # Left contraction: grade(result) = grade(b) - grade(a)
                if sign != 0.0 and grade_result == abs(grade_j - grade_i):
                    terms_by_blade[result_blade].append((i, j, sign))

        # Generate code for each result blade
        for blade_idx in range(n):
            terms = terms_by_blade[blade_idx]
            if not terms:
                continue

            blade_name = algebra.blade_name(blade_idx)
            expr_parts = []
            for i, j, sign in terms:
                if sign == 1.0:
                    expr_parts.append(f'a[{i}] * b[{j}]')
                elif sign == -1.0:
                    expr_parts.append(f'-a[{i}] * b[{j}]')

            if len(expr_parts) <= 4:
                expr = ' + '.join(expr_parts).replace('+ -', '- ')
                lines.append(f'    result[{blade_idx}] = {expr}  # {blade_name}')
            else:
                lines.append(f'    # {blade_name}')
                lines.append(f'    result[{blade_idx}] = (')
                for k, part in enumerate(expr_parts):
                    sep = '' if k == 0 else '+ '
                    if part.startswith('-'):
                        sep = '- ' if k > 0 else ''
                        part = part[1:]
                    lines.append(f'        {sep}{part}' + (',' if k < len(expr_parts) - 1 else ''))
                lines.append(f'    )')

        lines.extend([
            f'',
            f'    return result',
            f'',
        ])

        return '\n'.join(lines)

    def generate_sandwich(self, algebra: Algebra) -> str:
        """Generate unrolled sandwich product R * x * ~R."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def sandwich(r: {array_type}, x: {array_type}) -> {array_type}:',
            f'    """',
            f'    Compute the sandwich product r * x * reverse(r).',
            f'    ',
            f'    This is the fundamental transformation operation in GA,',
            f'    used for rotations, reflections, and other transformations.',
            f'    """',
            f'    # First compute r * x',
            f'    rx = geometric_product(r, x)',
            f'',
            f'    # Compute reverse of r',
            f'    r_rev = reverse(r)',
            f'',
            f'    # Return rx * r_rev',
            f'    return geometric_product(rx, r_rev)',
            f'',
        ]

        return '\n'.join(lines)

    def generate_reverse(self, algebra: Algebra) -> str:
        """Generate the reverse operation."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def reverse(a: {array_type}) -> {array_type}:',
            f'    """',
            f'    Compute the reverse (reversion) of a multivector.',
            f'    ',
            f'    Reverses the order of basis vectors in each blade.',
            f'    Sign pattern: grades 0,1 -> +1; grades 2,3 -> -1; grades 4,5 -> +1; ...',
            f'    """',
            f'    result = {zeros}',
        ]

        for i in range(n):
            sign = algebra.reverse_sign(i)
            blade_name = algebra.blade_name(i)
            if sign == 1.0:
                lines.append(f'    result[{i}] = a[{i}]  # {blade_name}')
            else:
                lines.append(f'    result[{i}] = -a[{i}]  # {blade_name}')

        lines.extend([
            f'    return result',
            f'',
        ])

        return '\n'.join(lines)

    def generate_grade_projection(self, algebra: Algebra) -> str:
        """Generate grade projection functions."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        lines = [
            f'def grade(a: {array_type}, k: int) -> {array_type}:',
            f'    """Extract the grade-k component of a multivector."""',
            f'    result = {zeros}',
            f'',
        ]

        # Generate switch-like structure
        for grade in range(algebra.dimension + 1):
            blades = algebra.blades_of_grade(grade)
            if not blades:
                continue

            lines.append(f'    if k == {grade}:')
            for blade_idx in blades:
                lines.append(f'        result[{blade_idx}] = a[{blade_idx}]')
            lines.append(f'        return result')

        lines.extend([
            f'',
            f'    return result',
            f'',
        ])

        # Generate specific grade projections
        for grade in range(algebra.dimension + 1):
            blades = algebra.blades_of_grade(grade)
            if not blades:
                continue

            grade_name = ['scalar', 'vector', 'bivector', 'trivector', 'quadvector'][grade] if grade < 5 else f'grade{grade}'

            lines.extend([
                f'',
                f'def {grade_name}_part(a: {array_type}) -> {array_type}:',
                f'    """Extract the grade-{grade} ({grade_name}) component."""',
                f'    result = {zeros}',
            ])
            for blade_idx in blades:
                lines.append(f'    result[{blade_idx}] = a[{blade_idx}]')
            lines.append(f'    return result')

        lines.append('')
        return '\n'.join(lines)

    def generate_norm(self, algebra: Algebra) -> str:
        """Generate norm computation."""
        lines = [
            f'def norm_squared(a: List[float]) -> float:',
            f'    """Compute |a|^2 = scalar_part(a * reverse(a))."""',
            f'    r = geometric_product(a, reverse(a))',
            f'    return r[0]',
            f'',
            f'',
            f'def norm(a: List[float]) -> float:',
            f'    """Compute |a| = sqrt(|a|^2)."""',
            f'    import math',
            f'    ns = norm_squared(a)',
            f'    return math.sqrt(abs(ns))',
            f'',
        ]
        return '\n'.join(lines)

    def generate_dual(self, algebra: Algebra) -> str:
        """Generate dual (multiplication by pseudoscalar inverse)."""
        n = algebra.num_blades
        array_type = 'np.ndarray' if self.use_numpy else 'List[float]'
        zeros = 'np.zeros(NUM_BLADES)' if self.use_numpy else '[0.0] * NUM_BLADES'

        # Pseudoscalar is highest-grade blade
        ps_idx = n - 1

        lines = [
            f'def dual(a: {array_type}) -> {array_type}:',
            f'    """',
            f'    Compute the dual of a multivector.',
            f'    ',
            f'    dual(a) = a * I^(-1) where I is the pseudoscalar.',
            f'    """',
            f'    # Pseudoscalar inverse for this algebra',
            f'    ps_inv = {zeros}',
        ]

        # Compute pseudoscalar squared
        _, ps_sq_sign = algebra.product(ps_idx, ps_idx)
        if ps_sq_sign == 0.0:
            lines.extend([
                f'    # Pseudoscalar is null - dual not well-defined',
                f'    raise ValueError("Dual not defined for algebras with null pseudoscalar")',
            ])
        else:
            ps_inv_sign = 1.0 / ps_sq_sign
            lines.append(f'    ps_inv[{ps_idx}] = {ps_inv_sign}')
            lines.extend([
                f'',
                f'    return geometric_product(a, ps_inv)',
            ])

        lines.append('')
        return '\n'.join(lines)

    def generate_full_module(self, algebra: Algebra, module_name: str) -> str:
        """Generate a complete Python module for the algebra."""
        parts = [
            self.generate_header(algebra, module_name),
            self.generate_blade_names(algebra),
            self.generate_grade_masks(algebra),
            self.generate_constructor(algebra),
            self.generate_reverse(algebra),
            self.generate_geometric_product(algebra),
            self.generate_outer_product(algebra),
            self.generate_inner_product(algebra),
            self.generate_grade_projection(algebra),
            self.generate_sandwich(algebra),
            self.generate_norm(algebra),
            self.generate_dual(algebra),
        ]

        return '\n'.join(parts)
